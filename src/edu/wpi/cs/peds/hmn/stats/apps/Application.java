/**
 * Class which holds information for identifying an application.
 */
package edu.wpi.cs.peds.hmn.stats.apps;

import java.io.Serializable;
import java.util.Date;

import org.json.JSONException;
import org.json.JSONObject;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;

import edu.wpi.cs.peds.hmn.appcollector.AppState;
import edu.wpi.cs.peds.hmn.appcollector.NetDevice;
import edu.wpi.cs.peds.hmn.stats.costbenefit.CostBenefit;
import edu.wpi.cs.peds.hmn.stats.costbenefit.StateChanges;
import edu.wpi.cs.peds.hmn.stats.net.NetUsageEntry;
import edu.wpi.cs.peds.hmn.stats.net.NetUsageList;
import edu.wpi.cs.peds.hmn.stats.net.NetworkStats;

/**
 * A container class for all information collected about an application. It also
 * is responsible for directing further data collection, such as network usage
 * and state information.
 * 
 * @author Austin Noto-Moniz, austinnoto@wpi.edu
 * 
 */
public class Application implements Serializable {
	/**
	 * Autogenerated VersionID
	 */
	private static final long serialVersionUID = 2965841186830803626L;
	
	private String name;
	
	public String packageName;
	public String version;
	public Integer uid;
	
	public Integer cost = 0;
	public Integer benefit = 0;
	
	public NetUsageList netUsage;
	public NetworkStats cumulativeStats;
	public NetDevice lastConnectionType;
	public AppStateMap appStateMap;
	public AppState currentState = null;
	public StateChanges stateChanges;
	
	public Float userRating = 0.0f;
	public Float dbRating = 0.0f;
	
	private long lastStateUpdateTime;
	
	public Application(String name, String packageName, int uid, String version)
	{
		this.name = name;
		this.packageName = packageName;
		this.uid = uid;
		this.version = version;
		
		netUsage = new NetUsageList();
		cumulativeStats = new NetworkStats();
		appStateMap = new AppStateMap();
		stateChanges = new StateChanges();
		
		lastStateUpdateTime = new Date().getTime();

		cost = (int)(Math.random()*100);
		benefit = (int)(Math.random()*100);
	}
	
	/**
	 * Tells the app it needs to update its stats, as well as informs the app of
	 * its current state.
	 * 
	 * @param context used for accessing system functions
	 * @param appState the app's current state
	 */
	public void updateStats(Context context, AppState appState)
	{
		updateState(appState);
		updateNetworkUsage(context);
		updateCostBenefit(context);
	}
	
	/**
	 * Updates the app's current state. In doing so, it also updates the app's
	 * total time spent in each state.
	 * 
	 * @param appState the app's current state
	 */
	private void updateState(AppState appState)
	{
		long currentTime = new Date().getTime();
		if (currentState == null)
		{
			currentState = appState;
			lastStateUpdateTime = currentTime;
		}
		else
		{
			long stateDuration = currentTime - lastStateUpdateTime;
			
			// Put this new entry in the state change list, which is currently
			// only used for cost/benefit calculation
			stateChanges.addChange(currentTime,appState,stateDuration);
			
			// Add this new entry to the total state duration
			long totalStateDuration = appStateMap.get(currentState);
			appStateMap.put(currentState,totalStateDuration+stateDuration);
			
			currentState = appState == null ? AppState.NOTRUNNING : appState;
			lastStateUpdateTime = currentTime;
		}
	}
	
	/**
	 * Updates the app's network usage totals, including the total data sent
	 * and received across each connection type.
	 * 
	 * @param context used to access system functions
	 */
	private void updateNetworkUsage(Context context)
	{
		NetworkStats totalStats = NetworkStats.getTotalNetworkUsage(uid);
		NetworkStats newStats = totalStats.difference(cumulativeStats);
		newStats.state = currentState;
		cumulativeStats = totalStats;
		
		NetUsageEntry newEntry = new NetUsageEntry(lastConnectionType, newStats);
		netUsage.add(newEntry);
		
		ConnectivityManager connectivityManager = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo activeNetwork = connectivityManager.getActiveNetworkInfo();
		lastConnectionType = NetDevice.determineNetworkConnection(activeNetwork);
	}
	
	/**
	 * Updates the app's user rating. This should only be called when the user
	 * changes their rating of the app.
	 * 
	 * @param newRating the new user rating for this app
	 */
	public void updateRating(Float newRating)
	{
		this.userRating = newRating;
	}
	
	/**
	 * Tells the app to update its cost/benefit calculation.
	 * At the moment, this method does nothing. The cost and benefit are
	 * randomly determined in the constructor.
	 * 
	 * @param context for accessing system functions
	 */
	private void updateCostBenefit(Context context)
	{
		/*
		benefit = CostBenefit.calcBenefit(context);
		cost = CostBenefit.calcCost(context);
		*/
	}
	
	/**
	 * Resets data collected by this app.
	 */
	public void resetStats()
	{
		netUsage = new NetUsageList();
		appStateMap = new AppStateMap();
	}
	
	/**
	 * Returns the app's human readable name, if it exists. Otherwise, returns
	 * its package name.
	 * 
	 * @return the name of this app
	 */
	public String getName()
	{
		return name == null ? packageName : name;
	}
	
	@Override
	public boolean equals(Object obj)
	{
		Application app = (Application)obj;
		return this.getName().equalsIgnoreCase(app.getName());
	}
	
	
	@Override
	public String toString()
	{
		return this.getName();
	}
	
	public String detailedInfo()
	{
		StringBuilder appStr = new StringBuilder();

		appStr.append(String.format("STATE INFO\n%s\n\n",appStateMap.detailedInfo()));
		appStr.append(String.format("NETWORK USAGE\n%s\n\n",netUsage.detailedInfo()));
		if (!netUsage.isEmpty())
			appStr.append(String.format("ENTRIES\n%s\n\n",netUsage.entryListDetails()));
		
		return appStr.toString();
	}
	
	public JSONObject toJSON() throws JSONException
	{
		JSONObject json = new JSONObject();
		
		json.put("name",getName());
		json.put("currentState",currentState.toJSONName());
		json.put("stateTime",appStateMap.toJSON());
		json.put("network",netUsage.toJSON());
		json.put("rating",userRating);
		
		return json;
	}
}
